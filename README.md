# Algorithm
* 알고리즘: 어떤 문제를 해결하기 위한 방법
* 자료구조: 데이터가 어떤 구조로 저장되고 어떻게 사용되는지를 나타냄

* 시간 복잡도: 특정 알고리즘이 어떤 문제를 해결하는 데 걸리는 시간

* 배열: 모든 프로그래밍 언어에서 기본적으로 제공하는 자료구조 (크기: 고정, 주소: 연속)
* 연결리스트: 노드들의 연결 구조 (크기: 동적, 주소: 불연속)

* 스택: 먼저 들어온게 나중에 쓰이는 데이터 구조

* 큐: 먼저 들어간 데이터가 먼저 나오는 데이터 구조

* 덱: 데이터의 삽입과 제거를 head와 tail에서 자유롭게 할 수 있는 구조

* 셋: 데이터의 중복을 허용하지 않는 자료구조

* 정렬
🔍 Bubble Sort
앞에서부터 인접한 두 원소를 보면서 앞의 원소가 뒤의 원소보다 클 경우 자리를 바꾸는 것을 반복하여 정렬한다.
시간복잡도는 O(N^2)이다.

🔍 Merge Sort
재귀적으로 수열을 나눠 정렬한 후 합치는 정렬이다.
시간복잡도는 O(NlgN)이다.
우선 순위가 같은 원소들끼리는 원래의 순서를 따라가도록 하는 정렬이 Stable Sort라고 하는데 Merge Sort가 이에 속한다.

🔍 Quick Sort
이름에서도 알 수 있듯이 일반적으로는 Quick Sort가 거의 모든 정렬 알고리즘보다 빨라서 각종 라이브러리의 정렬은 대부분 Quick Sort를 바탕으로 만들어졌다.
하지만, 기억해야할 점은 코딩테스트에서 STL을 못 쓰고 직접 정렬을 구현해야 한다면 Quick Sort는 절대 쓰면 안된다는 것이다.
Merge Sort처럼 재귀적으로 구현되는 정렬인데 매 단계마다 pivot이라고 이름 붙은 원소 하나를 제자리로 보내는 작업을 반복한다.
평균적으로 시간복잡도는 O(NlgN)이지만 최악의 경우 O(N^2)이다. 이러한 이유로 직접 정렬을 구현해야 한다면 Quick Sort를 절대 쓰면 안된다는 것이다.

🔍 Counting Sort
미리 큰 테이블을 만들어두고 수에 대응되는 원소의 값을 1 증가시켜서 정렬한다.
하지만 만약 수의 범위가 0에서 999,999,999 까지라고 하면 크기가 10억인 배열이 필요하므로 수의 범위가 어느 정도 한정적일 때에만 쓸 수 있다. 수의 범위가 대략 1000만 이하일 때에는 쓸 수 있다고 생각하면 된다.

🔍 Radix Sort
자릿수를 이용해서 정렬을 수행하는 알고리즘으로 Counting Sort를 응용한 알고리즘이라고 생각할 수 있다.
각 수들의 1의 자리만 보고 정렬을 하고, 그 후에는 10의 자리만 보고 정렬, 그 후에는 100의 자리, ... 이렇게 정렬을 수행한다.

Bubble Sort, Merge Sort, Quick Sort는 원소들끼리 크기를 비교하므로 Comparison Sort이고 Counting Sort, Radix Sort는 Non-comparison Sort이다.
